### 递归函数

> 递归函数就是定义了一个函数，然后在函数内，自己调用了自己这个函数
> 递归函数内必须要有结束，不然就会一只调用下去，直到调用的层数越来越多，栈溢出
> 递归函数是一层一层的进入，再一层一层的返回

##### 初步认识递归函数

```python
# 初步认识 递归函数  3 2 1 0
def digui(num):
    print(num) # 3 2 1 0
    # 检测当前的值是否到了零
    if num > 0:
        # 调用函数本身
        digui(num-1)
    print(num) # 0 1 2 3

digui(3)

'''
解析当前递归函数的执行过程：
digui(3) ==> 3 
    digui(3-1) ==> 2
        digui(2-1) ==> 1
            digui(1-1) ==> 0
            digui(0) ==> 0
        digui(1) ==> 1
    gidui(2) ==>2
digui(3) ==> 3
'''
```

### 回调函数

> 函数中的参数可以是任意类型的，那参数能不能是一个函数呢？
>
> 如果在一个函数中要求传递的参数是一个函数作为参数，并且在函数中使用了传递进来的函数，那么这个函数我们就可以称为是一个回调函数

```python
# 定义一个函数,函数中的一个参数要求是另一个函数
# 带有回调函数参数的函数
# def func(f):
    # print(f,type(f))
    # 并且在函数中调用了传递进来的行参函数
    # f()


# 回调函数
# def love():
#     print('123')
#
# func(love)
```



### 闭包函数

> 既然可以把函数作为一个行参进行传递，作为回调函数，那么如果在一个函数中，返回了一个函数呢？
>
> 在一个函数内返回了一个内函数， 并且这个返回的内函数还使用了外函数中局部变量，这就是闭包函数

**特点：**

1. 在外函数中定义了局部变量，并且在内部函数中使用了这个局部变量
2. 在外函数中返回了内函数，返回的内函数就是闭包函数
3. ⚠主要在于保护了外函数中的局部变量，既可以被使用，又不会被破坏
4. 检测一个函数是否为闭包函数，可以使用 `函数名.__closure__ `如果是闭包函数返回 cell

```python
# 定义一个函数
def person():
    money = 0  # 函数中定义了一个局部变量
    # 工作 定义的内函数
    def work():
        nonlocal money   # 在内函数中使用了外函数的临时变量
        money += 100
        print(money)
    # 在外函数中返回了内函数，这个内函数就是闭包函数
    return work

res = person() # return work  res = work
res() # res() == work()
res()
res()
res()
# 此时 就不能够在全局中对money这个局部变量进行任何操作了，
# 闭包的作用：保护了函数中的变量不受外部的影响，但是又能够不影响使用
```



### 匿名函数  lambda 表达式

> 匿名函数的意思就是说可以不使用def定义，并且这个函数也有没有名字
>
> 在python中可以使用lambda表达式来定义匿名函数
>
> 注意：lambda表达式仅仅是一个表达式，不是一个代码块，所以lambda又称为一行代码的函数
>
> lambda表达式也有行参，并且不能访问除了自己的行参之外的任何数据包括全局变量

```python
'''
语法：
lambda [参数列表]:返回值
'''

# 封装一个函数做加法运算
# 普通函数
def jia(x,y):
    return x+y

# print(jia(2,3))

# 改成lambda表达式来封装
res = lambda x,y:x+y
# print(res(4,4))

# 带有分支结构的lambda 表达式
#  lambda 参数列表: 真区间 if 表达式判断 else 假区间
res = lambda sex:"很man" if sex=='男' else "很nice"
print(res('女'))
```



### 迭代器

> 迭代器是python中最具特色的功能之一，是访问集合元素的一种方式
>
> 迭代器是一个可以记住访问遍历的位置的对象
>
> 从集合的第一个元素开始访问，直到集合中的所有元素被访问完毕
>
> 迭代器只能从前往后一个一个的便利，不能后退
>
> 能被next()函数调用，并不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）


#### iter()                        
> 功能：把可迭代的对象，转为一个迭代器对象          
> 参数：可迭代的对象 （str，list，tuple，dict
> 返回值： 迭代器对象                    
> 注意：迭代器一定是一个可以迭代的对象，但是可迭代对象不一定是迭代器 

#### next()
> next()函数可以去调用迭代器，并返回迭代器中的下一个数据

#### 迭代器的取值方案                                           

1. next() 调用一次获取一次，直到数据被取完                   
2. list() 使用list函数直接取出迭代器中的所有数据              
3. for    使用for循环遍历迭代器的数据                    
##### 迭代器取值的特点，取出一个少一个，直到都取完，最后再获取就会报错                 


#### 检测迭代器和可迭代对象的方法  

```python
from collections.abc import Iterator,Iterable                   
                                                                
varstr = '123456'                                               
res = iter(varstr)                                              
                                                                
# type() 函数返回当前数据的类型，                                           
# isinstance() 检测一个数据是不是一个指定的类型                                 
r1 = isinstance(varstr,Iterable) # True 可迭代对象                   
r2 = isinstance(varstr,Iterator) # False 不是一个迭代器                
r3 = isinstance(res,Iterable) # True 可迭代对象                      
r4 = isinstance(res,Iterator) # True 是一个迭代器                     
print(r1,r2)                                                    
print(r3,r4)         
# 迭代器一定是一个可迭代的对象，可迭代对象不一定是迭代器                                           
```



